# 시간 복잡도

- 알고리즘을 수행할 때 걸리는 시간을 기준으로 효율성을 분석하는 것입니다.
  - 시간의 효율성이란 알고리즘에서 비교와 교환이 일어날 때 연산자의 처리 횟수를 말합니다.
  - 즉 연산자의 처리 횟수가 적다는 건 시간의 복잡도가 낮다는 의미입니다.
  - 시간 복잡도가 낮을수록, 연산자의 사용 횟수가 적을수록 효율성이 높은 알고리즘이 됩니다.
- 표기방법에는 Big-O(빅-오), Big Ω(빅-오메가), 𝚹 (세타)가 있습니다.

<br>

<br>

## Big-O

- 컴퓨터 과학에서 "대략"을 나타내는 공식적인 개념으로 최악의 경우를 가정하며 시간복잡도를 말할때 일반적으로 사용됩니다.
- 연산자의 처리 횟수를 말합니다.

<br>

### 선형 탐색의 Big-O

- 선형탐색은 맨 처음부터 원하는 값을 찾아가는 탐색 방법으로 찾는 값이 배열의 맨 끝에 있는 상황이 최악의 상황입니다.
- 만약 5개의 숫자중 5가 맨끝에 있다면 1번부터 5번까지 확인하고 나서야 5를 찾을 수 있습니다. 이말은 n번의 숫자 만큼 있을때 n이 맨끝에 있다면 n번을 확인하고 나서야 n을 찾을수 있다는 말입니다. 
- 이를 빅오로 표현하면 O(n)이 됩니다.

<br>

<br>

### 버블 정렬의 Big-O

- 버블 정렬은 두개의 인접한 자료값을 비교하면서 정렬하는 방법으로 n개의 자료가 있으면 n-1번을 비교하는게 최악의 상황으로 볼수 있습니다.
- 만약 8개의 숫자중 시작이 8번이라면 7번이 비교가 되서야 8번의 자리에 숫자 8이 정렬 될수 있습니다. 다음 두번째 숫자가 7이라면 6번을 비교하고 나서야 7번째에 숫자 7이 정렬 될수 있습니다.
- 그렇게 봤을 때 전체 비교 횟수는 (n-1) + (n-2) + ... + 1이 됩니다. 
  - 이 식을 확장해 보면 다음과 같습니다.
    - n(n - 1) / 2
    - (n^2 - n)/2
    - n^2/2 - n/2
    - 시간 복잡도는 가장 지수가 큰(중요한) 부분만 남기고, 계수를 삭제합니다. 그래서 n^2/2남 남게되고  (1/2)n^2에서 계수를 제외하고 n2가 남게되어 O(n^2)로 표현합니다.
- 계수가 필요 없는 이유는 다음과 같습니다. 예를들어 1,000,000번 동작해야 하는 알고리즘이 있을때 추정 횟수는 500,000,000,000 - 500,000 = 499,999,500,000이 됩니다. 이는 속도로 봤을때 5천억번이 동작하는것과 5천억번에서 5십만번을 뺀 횟수만큼 동작하는건 큰 차이가 없을겁니다. 그렇기 때문에 입력값에 따라 가장 큰 영향을 많이 받는 n^2를 빼고 나머지는 제외하고 보게 됩니다.
- 물론 정확하게 볼려면 속도에 영향을 줄수 있는 많은 부분들에 대해서 고려를 해야 겠지만 그렇게 까지 한다면 서로 다른 컴퓨터에서 알고리즘을 돌렸을때 속도가 어떤 결과가 나오는지를 비교하기 매우 힘들것 같습니다. 그렇기 때문에 몇번 동작을 해야 하는지가 중요하게 되었고 나머지를 제외한다고 생각하면 이해가 조금은 쉬울것 같습니다.

<br>

<br>

### 선택 정렬의 Big-O

- 선택 정렬을 가장 작은(또는 가장 큰) 값을 찾아서 순서를 정리하는 정렬방법으로 n개의 자료가 있을때 첫번째 자료와 나머지 n-1개의 자료 중에 가장 작은 값의 자리를 교환해 줘야 합니다. n-1개의 자료 중에서 가장 작은 값을 찾기 위해서는 n-1번의 비교가 필요하게 되면 이는 버블정렬과 마찬가지로 시간복잡도 O(n^2)를 가지게 됩니다.

<br>

<br>

### 삽입 정렬의 big-O

- 삽입 정렬은 정렬된 부분과 정렬되지 않는 부분을 나워서 정렬하는 방법으로 n개의 자료가 있을때 첫 번째 자료를 정렬되어 있다고 생각하고, n-1개의 자료 중에서 첫번째 자료와 정렬된 자료를 비교하는 정렬방법입니다. 끝에 정렬되지 않는 부분에 1개의 자료가 남게되면 정렬된 자료의 수 n-1개만큼 비교가 필요하게 되면 총 비교횟수는 1 + 2 + ... + (n-1)이 됩니다. 버블 정렬과 마찬가지로 입력값이 가장 영향을 많이 받는 n^2만 남게 되고 시간복잡도는 O(n^2)이 됩니다.

<br>

<br>

## Big Ω

- 빅 오메가 표기법으로 최선의 경우를 나타냅니다.

<br>

### 선형 탐색의 Big Ω

- 최선의 경우는 배열의 처음에 찾고자 하는 값이 있는 상황으로 배열의 크기과 관계없이 Ω(1)입니다.

<br>

### 버블 정렬의 Big Ω 

- 정렬에서 최선의 상황은 정렬된 배열입니다. 버블 정렬은 정렬이 되어있는 상태에서도 정렬이 되어 있는지를 확인(정렬이 되어 있는지 알수 없기 때문에)해야 하기 때문에 n-1번만큼 비교를 해줘야 합니다. 그래서 Ω(n)이 됩니다.

<br>

### 선택 정렬의 Big Ω

- 정렬된 배열의 최소값을 찾기위해 전체를 비교해 줘야 하므로 Ω(n^2)로 표기합니다.

<br>

### 삽입 정렬의 Big Ω

- 정렬이 되어 있는 상태에서는 큰 수와 비교만 하면 되기 때문에 Ω(n)으로 표기합니다.
- [1, 2, 3, 4, 5, 6]

<br>

<br>

## 정리해서 보면

- O(1) - 상수 시간 : 입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거치게 됩니다.
- O(log n) - 로그 시간 : 입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해서 줄어들게 됩니다.
- O(n) - 직선적 시간 : 문제를 해결하기 위한 단계와 입력이 n이 1:1의 관계를 가집니다.
- O(n^2) - 2차 시간 : 해결을 위한 단계의 수는 입력값 n의 제곱입니다.

<br>